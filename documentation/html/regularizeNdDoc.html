
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>regularizeNd</title><meta name="generator" content="MATLAB 9.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2017-04-02"><meta name="DC.source" content="regularizeNdDoc.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>regularizeNd</h1><!--introduction--><p>regularizeNd  Fits a nD lookup table with smoothness to scattered data.</p><pre class="language-matlab">yGrid = regularizeNd(x, y, xGrid)
yGrid = regularizeNd(x, y, xGrid, smoothness)
yGrid = regularizeNd(x, y, xGrid, smoothness, interpMethod)
yGrid = regularizeNd(x, y, xGrid, smoothness, interpMethod, solver)
</pre><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Inputs</a></li><li><a href="#7">Output</a></li><li><a href="#8">Description</a></li><li><a href="#10">Acknowledgement</a></li><li><a href="#11">Example</a></li></ul></div><h2 id="1">Inputs</h2><p><b>x</b> - column vector or matrix of column vectors, containing scattered data. Each row contains one point. Each column corresponds to a dimension.</p><p><b>y</b> - vector containing the corresponds values to x. y has the same number of rows as x.</p><p><b>xGrid</b> - cell array containing vectors defining the nodes in the grid in each dimension. xGrid{1} corresponds with x(:,1) for instance. Unequal spacing in the grid vectors is allowed. The grid vectors must completely span x. For instance the values of x(:,1) must be within the bounds of xGrid{1}. If xGrid does not span x, an error is thrown.</p><p><b>smoothness</b> - scalar or vector. - The numerical "measure" of what we want to achieve along an axis/dimension, regardless of the resolution, the aspect ratio between axes, or the scale of the overall problem. The ratio of smoothness to fidelity of the output surface, i.e. ratio of smoothness to "goodness of fit." This must be a positive real number. If it is a vector, it must have same number of elements as columns in x.</p><p>A smoothness of 1 gives equal weight to fidelity (goodness of fit) and smoothness of the output surface.  This results in noticeable smoothing. If your input data has little or no noise, use 0.01 to give smoothness 1% as much weight as goodness of fit. 0.1 applies a little bit of smoothing to the output surface.</p><p>If this parameter is a vector, then it defines the relative smoothing to be associated with each axis/dimension. This allows the user to apply a different amount of smoothing in the each axis/dimension.</p><pre class="language-matlab">DEFAULT: 0.01
</pre><p><b>interpMethod</b> - character, denotes the interpolation scheme used to interpolate the data.</p><div><ul><li>'linear' - Uses linear interpolation within the grid. linear                     interpolation requires that extrema occur at the grid                     points. linear should be smoother than nearest for                     the same grid. As the number of dimension grows,                    the number of grid points used to interpolate at a                    query point grows with 2^nDimensions. i.e. 2d needs 4                    points, 3d needs 8 points, 4d needs 16 points per                    query point. Linear has good properies of speed and                    accuracy.</li></ul></div><div><ul><li>'nearest' - nearest neighbor interpolation. Nearest should                      be the fastest because of simplicity but least                      accurate.</li></ul></div><div><ul><li>'cubic' - Uses lagrange cubic interpolation. Cubic interpolation                    allows extrema to occur at other locations besides the                    grid points. Cubic should provide the most flexible                    relationship for a given xGrid at the cost of                    computation time. As the number of dimension grows,                    the number of grid points used to interpolate at a                    query point grows with 4^nDimensions. i.e. 2d needs 16                    points, 3d needs 64 points, 4d needs 256 points per                    query point. cubic has good properties of accuracy and                    smoothness but should be the slowest.</li></ul></div><pre class="language-matlab">DEFAULT: <span class="string">'linear'</span>
</pre><p><b>solver</b> - character flag - denotes the solver used for the          resulting linear system. The default is most often the best          choice.</p><p>What solver should you use? '\' may be best numerically for most          smoothness parameters and high extents of extrapolation. If you          receive rank deficiency warnings, try the '\' solver. Otherwise,          use the 'normal' solver because it is usually faster than the '\'          solver.</p><p>Large numbers of points will slow down the direct '\'. Since the          equations generated by this regularization method tends to be          well conditioned, the 'normal' solver is  a good choice. Beware          using 'normal' when a small smoothing parameter is used,          since this will make the equations less well conditioned. The          'normal' solver for fairly large grids is 3x faster than the '\'.</p><div><ul><li>'\' - uses matlab's backslash operator to solve the sparse                system.</li></ul></div><div><ul><li>'normal' - Constructs the normal equation and solves.                     x = (A'A)\(A'*y). From testing, this seems to be a well                     conditioned and faster way to solve this type of                     equation system than backslash x = A\y. Testing shows                     that the normal equation is 3x faster than the \                     solver for this type of problem. This goes against the                     general recommendation in numerical analysis but is                     has been proven to be true through testing.</li></ul></div><pre class="language-matlab">DEFAULT: <span class="string">'normal'</span>
</pre><h2 id="7">Output</h2><p><b>yGrid</b> - array containing the fitted surface correspond to the grid            points xGrid. yGrid is in the ndgrid format. In 2d, ndgrid            format is the transpose of meshgrid format.</p><h2 id="8">Description</h2><p>regularizeNd answers the question what is the best possible lookup table that the scattered data input x and output y in the least squares sense with smoothing? regularizeNd is meant to calculate a smooth lookup table given n-D scattered data. regularizeNd supports extrapolation from a scattered data set as well.</p><p>The calculated lookup table yGrid is meant to be used with griddedInterpolant class with the conservative memory form. Call griddedInterpolant like F = griddedInterpolant(xGrid, yGrid).</p><p>Desirable properties of regularizeNd:</p><div><ul><li>Calculates a relationship between the input x and the output y       without definition of the functional form of x to y.</li><li>Often the fit is superior to polynomial type fitting without       the wiggles.</li><li>Extrapolation is possible from a scattered data set.</li><li>After creating the lookup table yGrid and using it with       griddedInterpolant, as the query point moves away from the       scattered data, the relationship between the input x and output y       becomes more linear because of the smoothness equations and no       nearby fidelity equations. The linear relationship is a good       choice when the relationship between x and y is unknown in       extrapolation.</li><li>regularizeNd can handle 1D, 2D, nD input data to 1D output data.        RegularizeData3D and gridfit can only handle 2D input and 1D out       (total 3D).</li><li>regularizeNd can handle setting the smoothness to 0 in any        axis/dimension. This means no smoothing is applied in a particular        axis/dimension and the data is just a least squares fit of a lookup        table in that axis/dimension.</li></ul></div><p>For an introduction on how regularization works, start here: <a href="https://mathformeremortals.wordpress.com/2013/01/29/introduction-to-regularizing-with-2d-data-part-1-of-3/">https://mathformeremortals.wordpress.com/2013/01/29/introduction-to-regularizing-with-2d-data-part-1-of-3/</a></p><h2 id="10">Acknowledgement</h2><p>Special thanks to Peter Goldstein, author of RegularizeData3D, for his coaching and help through writing regularizeNd.</p><h2 id="11">Example</h2><pre class="codeinput"><span class="comment">% setup some input points, output points, and noise</span>
x = 0.5:0.1:4.5;
y = 0.5:0.1:5.5;
[xx,yy] = ndgrid(x,y);
z = tanh(xx-3).*sin(2*pi/6*yy);
noise = (rand(size(xx))-0.5).*xx.*yy/30;
zNoise = z + noise;

<span class="comment">% setup the grid for lookup table</span>
xGrid = linspace(0,6,21);
yGrid = linspace(0,6.6,19);
gridPoints = {xGrid, yGrid};

<span class="comment">% setup some difference in scale between the different dimensions/axes to</span>
<span class="comment">% just show the effectiveness of regularizeNd's capability of handling</span>
<span class="comment">% different scales in different dimensions.</span>
xScale = 100;
x = xScale*x;
xx=xScale*xx;
xGrid = xScale*xGrid;
gridPoints{1} = xGrid;

<span class="comment">% smoothness parameter. i.e. fit is weighted 1000 times greater than</span>
<span class="comment">% smoothness.</span>
smoothness = 0.001;

<span class="comment">% regularize</span>
zGrid = regularizeNd([xx(:), yy(:)], zNoise(:), gridPoints, smoothness);
<span class="comment">% Note this s the same as</span>
<span class="comment">% zGrid = regularizeNd([xx(:), yy(:)], zNoise(:), gridPoints, smoothness, 'linear', 'normal');</span>

<span class="comment">% create girrdedInterpolant function</span>
F = griddedInterpolant(gridPoints, zGrid, <span class="string">'linear'</span>);

<span class="comment">% plot and compare</span>
screenSize = get(0, <span class="string">'screenSize'</span>);
figure(<span class="string">'position'</span>, [screenSize(3:4)*.1, 800, 600]);
surf(x,y,z', <span class="string">'FaceColor'</span>, <span class="string">'g'</span>)
hold <span class="string">all</span>;
surf(x,y,zNoise')
surf(xGrid, yGrid, zGrid', <span class="string">'FaceColor'</span>, <span class="string">'r'</span>)
xlabel(<span class="string">'x'</span>)
ylabel(<span class="string">'y'</span>)
zlabel(<span class="string">'z'</span>)
legend({<span class="string">'Exact'</span>, <span class="string">'Noisy'</span>, <span class="string">'regularizeNd'</span>},<span class="string">'location'</span>, <span class="string">'best'</span>);
</pre><img vspace="5" hspace="5" src="regularizeNdDoc_01.png" alt=""> <p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2016b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% regularizeNd
% regularizeNd  Fits a nD lookup table with smoothness to scattered data.
%
%   yGrid = regularizeNd(x, y, xGrid)
%   yGrid = regularizeNd(x, y, xGrid, smoothness)
%   yGrid = regularizeNd(x, y, xGrid, smoothness, interpMethod)
%   yGrid = regularizeNd(x, y, xGrid, smoothness, interpMethod, solver)
%
%% Inputs
% *x* - column vector or matrix of column vectors, containing scattered
% data. Each row contains one point. Each column corresponds to a
% dimension.
%%%
% *y* - vector containing the corresponds values to x. y has the same
% number of rows as x.
%%%
% *xGrid* - cell array containing vectors defining the nodes in the grid in
% each dimension. xGrid{1} corresponds with x(:,1) for instance. Unequal
% spacing in the grid vectors is allowed. The grid vectors must completely
% span x. For instance the values of x(:,1) must be within the bounds of
% xGrid{1}. If xGrid does not span x, an error is thrown.
%%%
% *smoothness* - scalar or vector. - The numerical "measure" of what we
% want to achieve along an axis/dimension, regardless of the resolution,
% the aspect ratio between axes, or the scale of the overall problem. The
% ratio of smoothness to fidelity of the output surface, i.e. ratio of
% smoothness to "goodness of fit." This must be a positive real number. If
% it is a vector, it must have same number of elements as columns in x.
%
% A smoothness of 1 gives equal weight to fidelity (goodness of fit) and
% smoothness of the output surface.  This results in noticeable smoothing.
% If your input data has little or no noise, use 0.01 to give smoothness 1%
% as much weight as goodness of fit. 0.1 applies a little bit of smoothing
% to the output surface.
%
% If this parameter is a vector, then it defines the relative smoothing to
% be associated with each axis/dimension. This allows the user to apply a
% different amount of smoothing in the each axis/dimension.
%
%   DEFAULT: 0.01
%%%
% *interpMethod* - character, denotes the interpolation scheme used to
% interpolate the data.
% 
% * 'linear' - Uses linear interpolation within the grid. linear
%                     interpolation requires that extrema occur at the grid
%                     points. linear should be smoother than nearest for
%                     the same grid. As the number of dimension grows,
%                    the number of grid points used to interpolate at a
%                    query point grows with 2^nDimensions. i.e. 2d needs 4
%                    points, 3d needs 8 points, 4d needs 16 points per
%                    query point. Linear has good properies of speed and
%                    accuracy.
%
% * 'nearest' - nearest neighbor interpolation. Nearest should
%                      be the fastest because of simplicity but least
%                      accurate.
% 
% * 'cubic' - Uses lagrange cubic interpolation. Cubic interpolation
%                    allows extrema to occur at other locations besides the
%                    grid points. Cubic should provide the most flexible
%                    relationship for a given xGrid at the cost of
%                    computation time. As the number of dimension grows,
%                    the number of grid points used to interpolate at a
%                    query point grows with 4^nDimensions. i.e. 2d needs 16
%                    points, 3d needs 64 points, 4d needs 256 points per
%                    query point. cubic has good properties of accuracy and
%                    smoothness but should be the slowest.
%
%
%   DEFAULT: 'linear'
%
%%%
% *solver* - character flag - denotes the solver used for the
%          resulting linear system. The default is most often the best
%          choice.
%
% What solver should you use? '\' may be best numerically for most
%          smoothness parameters and high extents of extrapolation. If you
%          receive rank deficiency warnings, try the '\' solver. Otherwise,
%          use the 'normal' solver because it is usually faster than the '\'
%          solver.
%
% Large numbers of points will slow down the direct '\'. Since the
%          equations generated by this regularization method tends to be
%          well conditioned, the 'normal' solver is  a good choice. Beware
%          using 'normal' when a small smoothing parameter is used,
%          since this will make the equations less well conditioned. The
%          'normal' solver for fairly large grids is 3x faster than the '\'.
%
% * '\' - uses matlab's backslash operator to solve the sparse
%                system.
%
%
% * 'normal' - Constructs the normal equation and solves.
%                     x = (A'A)\(A'*y). From testing, this seems to be a well
%                     conditioned and faster way to solve this type of
%                     equation system than backslash x = A\y. Testing shows
%                     that the normal equation is 3x faster than the \
%                     solver for this type of problem. This goes against the
%                     general recommendation in numerical analysis but is 
%                     has been proven to be true through testing.
%
%   DEFAULT: 'normal'
%
%
%
%% Output
% *yGrid* - array containing the fitted surface correspond to the grid
%            points xGrid. yGrid is in the ndgrid format. In 2d, ndgrid
%            format is the transpose of meshgrid format.
%
%% Description
% regularizeNd answers the question what is the best possible lookup table
% that the scattered data input x and output y in the least squares sense
% with smoothing? regularizeNd is meant to calculate a smooth lookup table
% given n-D scattered data. regularizeNd supports extrapolation from a
% scattered data set as well.
%
% The calculated lookup table yGrid is meant to be used with
% griddedInterpolant class with the conservative memory form. Call
% griddedInterpolant like F = griddedInterpolant(xGrid, yGrid).
% 
% Desirable properties of regularizeNd:
%%%
% * Calculates a relationship between the input x and the output y
%       without definition of the functional form of x to y.
% * Often the fit is superior to polynomial type fitting without 
%       the wiggles.
% * Extrapolation is possible from a scattered data set. 
% * After creating the lookup table yGrid and using it with
%       griddedInterpolant, as the query point moves away from the
%       scattered data, the relationship between the input x and output y
%       becomes more linear because of the smoothness equations and no
%       nearby fidelity equations. The linear relationship is a good
%       choice when the relationship between x and y is unknown in
%       extrapolation.
% * regularizeNd can handle 1D, 2D, nD input data to 1D output data.
%        RegularizeData3D and gridfit can only handle 2D input and 1D out
%       (total 3D). 
% * regularizeNd can handle setting the smoothness to 0 in any
%        axis/dimension. This means no smoothing is applied in a particular
%        axis/dimension and the data is just a least squares fit of a lookup
%        table in that axis/dimension.
%
% For an introduction on how regularization works, start here:
% <https://mathformeremortals.wordpress.com/2013/01/29/introduction-to-regularizing-with-2d-data-part-1-of-3/>
%
%% Acknowledgement
% Special thanks to Peter Goldstein, author of RegularizeData3D, for his
% coaching and help through writing regularizeNd.
%
%% Example

% setup some input points, output points, and noise
x = 0.5:0.1:4.5;
y = 0.5:0.1:5.5;
[xx,yy] = ndgrid(x,y);
z = tanh(xx-3).*sin(2*pi/6*yy);
noise = (rand(size(xx))-0.5).*xx.*yy/30;
zNoise = z + noise;

% setup the grid for lookup table
xGrid = linspace(0,6,21);
yGrid = linspace(0,6.6,19);
gridPoints = {xGrid, yGrid};

% setup some difference in scale between the different dimensions/axes to
% just show the effectiveness of regularizeNd's capability of handling
% different scales in different dimensions.
xScale = 100;
x = xScale*x;
xx=xScale*xx;
xGrid = xScale*xGrid;
gridPoints{1} = xGrid; 

% smoothness parameter. i.e. fit is weighted 1000 times greater than
% smoothness.
smoothness = 0.001;

% regularize
zGrid = regularizeNd([xx(:), yy(:)], zNoise(:), gridPoints, smoothness);
% Note this s the same as 
% zGrid = regularizeNd([xx(:), yy(:)], zNoise(:), gridPoints, smoothness, 'linear', 'normal');

% create girrdedInterpolant function
F = griddedInterpolant(gridPoints, zGrid, 'linear');

% plot and compare
screenSize = get(0, 'screenSize');
figure('position', [screenSize(3:4)*.1, 800, 600]);
surf(x,y,z', 'FaceColor', 'g')
hold all;
surf(x,y,zNoise')
surf(xGrid, yGrid, zGrid', 'FaceColor', 'r')
xlabel('x')
ylabel('y')
zlabel('z')
legend({'Exact', 'Noisy', 'regularizeNd'},'location', 'best');
##### SOURCE END #####
--></body></html>